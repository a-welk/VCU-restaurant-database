---
title: Project Deliverable 7 Final Submission 
author: Edwin Constancia and Alex Welk
date: last-modified 
format:
  html:
    theme: cosmo
    toc: true
    embed-resources: true
---

<style>
body {
  background-color: #92a8d1 !important; /* Slightly lighter background color */
  color: #333333; /* Complementary text color */
  font-family: 'Roboto', sans-serif; /* Custom font (Roboto) */
  margin: 20px; /* Adjust margin for the entire page */
  line-height: 1.6; /* Adjust line height for readability */
}

h1 {
  margin: 20px 0; /* Adjust margin for h1 (main headers) */
  color: #002240; /* Header color (dark blue) */
}

h2 {
  margin: 15px 0; /* Adjust margin for h2 (sub-headers) */
  color: #002240; /* Header color (dark blue) */
}

p {
  margin: 10px 0; /* Adjust margin for paragraphs */
}

a {
  color: #black; /* Link color (orange) */
}

table {
  font-family: Roboto, sans-serif;

  border-collapse: collapse; /* Merge table borders for a solid line */
  border: 2px solid black; /* Add a 2px black border around the table */
}

th {
  background-color: #4CAF50;
  color: black;
  border: 2px solid white; /* Add a 2px black border around headers */
}

table caption {
  text-align: center;
}

</style>

```{python}
#| eval: true
#| echo: false
import os
import sys
import pandas as pd
from tabulate import tabulate
from dotenv import load_dotenv
from sqlalchemy import create_engine, text
from sqlalchemy.exc import OperationalError, ProgrammingError
from IPython.display import display, Markdown
```

```{python}
#| eval: true
#| echo: false

# modify config_map to reflect credentials needed by this program
config_map = {
    'user':'CMSC508_USER',
    'password':'CMSC508_PASSWORD',
    'host':'CMSC508_HOST',
    'database':'PROJECT_DB_NAME'
}
# load and store credentials
load_dotenv()
config = {}
for key in config_map.keys():
    config[key] = os.getenv(config_map[key])
flag = False
for param in config.keys():
    if config[param] is None:
        flag = True
        print(f"Missing {config_map[param]} in .env file")
#if flag:
#    sys.exit(1)
```

```{python}
#| eval: true
#| echo: false

# build a sqlalchemy engine string
engine_uri = f"mysql+pymysql://{config['user']}:{config['password']}@{config['host']}/{config['database']}"

# create a database connection.  THIS IS THE ACTUAL CONNECTION!
try:
    cnx = create_engine(engine_uri)
except ArgumentError as e:
    print(f"create_engine: Argument Error: {e}")
    #sys.exit(1)
except NoSuchModuleError as e:
    print(f"create_engine: No Such Module Error: {e}")
    #sys.exit(1)
except Exception as e:
    print(f"create_engine: An error occurred: {e}")
    #sys.exit(1)
```

```{python}
#| echo: false
#| eval: true

# Do a quick test of the connection and trap the errors better!
try:
    databases = pd.read_sql("show databases",cnx)
except ImportError as e:
    print(f"Error: {e}")
except OperationalError as e:
    print(f"Database/SQL Error:\n{str(e)}\n")
except ProgrammingError as e:
    print(f"Programming Error:\n{str(e)}\n")
except Exception as e:
    print(f"An error occurred:\n{str(e)}\n")

```

# Project Overview

This database project focuses on addressing the dining challenges faced by Virginia Commonwealth University (VCU) students in Richmond. It aims to provide VCU students with a comprehensive resource that simplifies the process of finding nearby restaurants, exploring their menus, evaluating pricing, dietary preferences, and special discounts, and reading user reviews. By offering real-time, customizable dining options and proximity-based recommendations, the database enhances the overall dining experience for students, facilitating informed decision-making that caters to their culinary cravings, budgets, and location preferences.

- **Pitch Video**: [Link to Pitch Video](https://cdnapisec.kaltura.com/index.php/extwidget/preview/partner_id/1888231/uiconf_id/28242191/entry_id/1_z86s0xo9/embed/dynamic)
- **Design Video**: [Link to Design Video](https://cdnapisec.kaltura.com/index.php/extwidget/preview/partner_id/1888231/uiconf_id/28242191/entry_id/1_ft7h6ed9/embed/dynamic)
- **GitHub Repository**: [Link to GitHub Repository](https://github.com/cmsc-vcu/cmsc508-fa2023-prj-restaurantdirectory-group21/tree/main)
- **Final Video Presentation**: [Link to Design Video](https://cdnapisec.kaltura.com/index.php/extwidget/preview/partner_id/1888231/uiconf_id/28242191/entry_id/1_ft7h6ed9/embed/dynamic)

# Problem Description

## Problem Domain

The problem domain we're addressing involves VCU students' dining choices, specifically those who struggle to find affordable dining options that match their cravings while staying within their budget. Many students face the challenge of balancing their culinary preferences with limited financial resources. This issue is common on the campus of Virginia Commonwealth University (VCU) in Richmond, and it can be a hassle to locate nearby dining options.

## Need 

The database was meticulously crafted to tackle the dining challenges faced by VCU students by consolidating comprehensive information about local restaurants, their menus, pricing, notable dishes, dietary preferences,, visitor reviews, and less than mile distancefrom campus. It stands as a centralized hub providing students with a wealth of dining options, catering to individual cravings, financial constraints, infromation on preferences for nearby dining establishments. The database is geared towards elevating the dining experience for VCU students. It streamlines the process of discovering satisfying meals within budgetary limits and close proximity, eliminating the hassle of extensive travel for dining.


## Context, Scope, and Perspective

The database is primarily designed for VCU students. Its perspective represents the student population at VCU who encounter challenges in finding suitable dining options on and around campus. It aims to empower students by offering a user-friendly platform tailored to their preferences and needs, including the convenience of locating nearby restaurants. 

## User roles and use cases

The database caters to various user roles, including VCU students, local restaurant owners, and administrators. VCU students primarily use the database to discover nearby restaurants, explore menu offerings, and find dietary preferences, helping them make informed dining choices. Restaurant owners input and manage information about their establishments, ensuring accurate representation. Administrators oversee the database's functionality and data quality. The database serves as a standalone platform, but it can be integrated with VCU's existing systems to enhance the student experience by providing location-based dining information.


## Security and Privacy

In our database design, we're planning to take robust measures to protect our restaurant's proprietary information, which includes critical data like restaurant locations, pricing, and our unique menu offerings. We understand that this information is not only a valuable asset but also essential to our competitive advantage. To secure it, we intend to establish stringent access controls. Our approach will involve implementing role-based access control, ensuring that only authorized individual can access or modify this vital data. By taking these steps, we aim to maintain the integrity of our business model and data, making sure it remains confidential and protected from unauthorized access.



# Database Design

## Entity-Relationship Diagram (ERD)

The following is an entity-relationship diagram (ERD) depicting the database's logical architecture:


```{mermaid}
erDiagram
    restaurants||--|{ locations : "Located at"
    restaurants ||--o{ review : "Has"
    restaurants ||--o{ accessibility : "Has"
    restaurants ||--|{ menu : "Has"
    menu }|--o{ menu_items : "Includes"
    item }|--|| menu_items : "Included in"
    item ||--o{ dietary_preference : "follows"


    dietary_preference {
        int dietary_preference_id
        varchar_256 dietary_preference_name
        primary_key dietary_preference_id
    }

    locations {
        int location_id
        varchar_256 location_address
        varchar_32 location_direction_from_VCU
        varchar_256 location_neighborhood
        primary_key location_id
    }

    restaurants {
        primary_key restaurant_id
        varchar restaurant_name
        varchar restaurant_formality_level
        varchar restaurant_avg_total_per_person
        int restaurant_location_id
        varchar restaurant_type
        foreign_key restaurant_location_id
    }

    review {
        int review_id
        int review_restaurant_id
        float review_rating
        varchar_1026 review_text
        date review_date
        primary_key review_id 
        foreign_key review_restaurant_id
    }

    accessibility {
        int accessibility_id
        int accessibility_restaurant_id
        float accessibility_miles_to_VCU
        varchar_256 accessibility_nearby_bus_stops
        varchar_256 accessibility_notes
        primary_key accessibility_id
        foreign_key accessibility_restaurant_id
    }

    menu {
        int menu_id
        int restaurant_id
        primary_key menu_id
        foreign_key restaurant_id
    }

    item {
        int item_id
        int item_dietary_preference_id
        varchar_256 item_name
        varchar_512 item_description
        float item_price
        primary_key item_id
        foreign_key item_dietary_preference_id
    }

    menu_items {
        int menu_item_id
        int menu_id
        int item_id
        primary_key menu_item_id
        foreign_key menu_id
        foreign_key item_id
    }



```



## Relational Schemas

### Restaurants
- **Attributes**: restaurant_id (PK), restaurant_name, restaurant_formality_level, restaurant_avg_total_per_person, restaurant_location_id (FK), restaurant_type
- **Types**: Integer, String, String, Numeric, Integer, String
- **Primary Key**: restaurant_id
- **Foreign Keys**: restaurant_location_id (locations)

### Location
- **Attributes**: location_id (PK), location_address, location_neighborhood, location_direction_from_VCU
- **Types**: Integer, String, String, String
- **Primary Key**: location_id

### Menu
- **Attributes**: menu_id (PK), restaurant_id (FK), item_id (FK)
- **Types**: Integer, Integer, Integer
- **Primary Key**: menu_id
- **Foreign Keys**: restaurant_id (restaurants), item_id (items)

### Items
- **Attributes**: item_id (PK), item_name, item_description, item_price, item_dietary_preference_id (FK)
- **Types**: Integer, String, String, Numeric, Integer
- **Primary Key**: item_id
- **Foreign Key**: item_dietary_preference_id (dietary_preference)

### Accessibility
- **Attributes**: accessibility_id (PK), accessibility_restaurant_id (FK), accessibility_nearby_bus_stops, accessibility_notes
- **Types**: Integer, Integer, String, String
- **Primary Key**: accessibility_id
- **Foreign Key**: accessibility_restaurant_id (restaurants)

### Reviews
- **Attributes**: review_id (PK), review_restaurant_id (FK), review_rating, review_text
- **Types**: Integer, Integer, Numeric, String
- **Primary Key**: review_id
- **Foreign Key**: review_restaurant_id (restaurants)

### Dietary Preference
- **Attributes**: dietary_preference_id (PK), dietary_preference_name
- **Types**: Integer, String
- **Primary Key**: dietary_preference_id

**Constraints**

- Primary keys enforce uniqueness and identify each record.
- Foreign keys establish relationships between tables.
- Attribute domains define the data types for each attribute.

## Functional Dependencies and Normalization

### Functional Dependencies

Let's analyze the functional dependencies (FDs) in the proposed database schema:

1. In the **Restaurants** relation:
   - `restaurant_id` $\rightarrow$ `restaurant_name`, `restaurant_location_id`

2. In the **Location** relation:
   - `location_id` $\rightarrow$ `location_address`, `location_neighborhood`, `location_direction_from_VCU`

3. In the **Menu** relation:
   - `menu_id` $\rightarrow$ `restaurant_id`

4. In the **Items** relation:
   - `item_id` $\rightarrow$ `item_name`, `item_description`, `item_price`, `item_dietary_preference_id`

5. In the **Accessibility** relation:
   - `accessibility_id` $\rightarrow$ `accessibility_restaurant_id`, `accessibility_nearby_bus_stops`, `accessibility_notes`

6. In the **Reviews** relation:
   - `review_id` $\rightarrow$ `review_restaurant_id`, `review_rating`, `review_text`

7. In the **Dietary Preference** relation:
   - `dietary_preference_id` $\rightarrow$ `dietary_preference_name`

### Normalization to BCNF

To achieve Boyce-Codd Normal Form (BCNF), we ensure that for any non-trivial FD, the left-hand side (LHS) is a superkey. The decomposition of the schema into BCNF is as follows:

- **Restaurants**, **Location**, **Menu**, **Items**, **Accessibility**, **Reviews**, and **Dietary Preference** remain as is, as their FDs hold for their primary keys.

- The other tables do not require further decomposition as their FDs adhere to BCNF.

### Decomposition

Here's a summary of the decomposition and their respective functional dependencies:

* $R_{0}(\text{Restaurant ID}, \text{Name}, \text{Location ID})$ having FD(s): $\text{Restaurant ID} \rightarrow \text{Name}$ and $\text{Location ID} \rightarrow \text{Address, Neighborhood, Cardinal Direction from VCU}$
  - Explanation: 
    - $R_{0}$ represents the `restaurants` table and its dependencies.
    - `Restaurant ID` uniquely determines `Name`.
    - `Location ID` uniquely determines `Address`, `Neighborhood`, and `Cardinal Direction from VCU`.

- $R_{1}(\text{Location ID}, \text{Address}, \text{Neighborhood}, \text{Cardinal Direction from VCU})$ having FD(s): No additional functional dependencies
  - Explanation:
    - $R_{1}$ corresponds to the `locations` table, capturing location-specific details.
    - No additional functional dependencies exist within this relation.

- $R_{2}(\text{Menu ID}, \text{Restaurant ID}, \text{Type})$ having FD(s): $\text{Restaurant ID} \rightarrow \text{Type}$
  - Explanation:
    - $R_{2}$ pertains to the `menu` table and its dependency on restaurant IDs.
    - `Restaurant ID` determines `Type` within this relation.

- $R_{3}(\text{Item ID}, \text{Item Name}, \text{Description}, \text{Price}, \text{Dietary Preference ID})$ having FD(s): $\text{Dietary Preference ID} \rightarrow \text{Preference Name}$
  - Explanation:
    - $R_{3}$ reflects the `items` table and its dependencies.
    - `Dietary Preference ID` determines `Preference Name` uniquely in this context.

- $R_{4}(\text{Accessibility ID}, \text{Restaurant ID}, \text{Nearby Bus Stops}, \text{Sidewalk Availability})$ having FD(s): $\text{Restaurant ID} \rightarrow \text{Name}$
  - Explanation:
    - $R_{4}$ doesn't directly align but demonstrates a dependency similar to the accessibility details, reflecting restaurant names based on `Restaurant ID`.

- $R_{5}(\text{Review ID}, \text{Restaurant ID}, \text{Rating}, \text{Review Text})$ having FD(s): $\text{Restaurant ID} \rightarrow \text{Name}$
  - Explanation:
    - $R_{5}$ mirrors the `reviews` table, indicating dependencies related to restaurant names based on `Restaurant ID`.


## Specific Queries

Pose 20 distinct questions that the database can help answer, written in precise words using relational algebra. Leverage Quarto to write the formulas.

---
column-style: "align: left;"
---


### Queries (Relational Algebra)
| Question | Relational Algebra Expression | Answer |
|----------|------------------------------|--------|
| Which restaurants have nearby bus stops and sidewalk availability? | $\pi_{\text{Name}}((\text{Accessibility} \bowtie \text{Restaurants}) \cap (\sigma_{\text{Sidewalk Availability} = \text{'Yes'}}(\text{Accessibility})))$ | Picolla Italy Pizza & Subs, Village Cafe, 821 Cafe, Crazy Thai Restaurant |
| What is the total count of visits for each restaurant offering discounts? | $\gamma_{\text{Sum(Count)}}(\text{Visits} \bowtie (\text{Discounts} \bowtie \text{Restaurants}))$ | Picolla Italy Pizza & Subs: 2, Village Cafe: 1, Kuba Kuba: 0, Dinamo: 0, 821 Cafe: 0, Crazy Thai Restaurant: 0 |
| Which restaurants offer discounts and have a formal level of "Casual"? | $\pi_{\text{Name}}((\text{Restaurants} \bowtie \text{Discounts}) \cap (\sigma_{\text{Formality Level} = \text{'Casual'}}(\text{Restaurants})))$ | Picolla Italy Pizza & Subs, Village Cafe, 821 Cafe |
| What is the average rating for restaurants in each neighborhood? | $\gamma_{\text{avg(Rating)}}(\text{Reviews} \bowtie \text{Restaurants} \bowtie \text{Location})$ | The Fan: 3.6, VCU: 5.0 |
| What is the total count of visits to "Village Cafe"? | $\gamma_{\text{Sum(Count)}}(\text{Visits} \bowtie (\sigma_{\text{Name} = \text{'Village Cafe'}}(\text{Restaurants})))$ | 5 |
| What is the total count of visits to "Kuba Kuba"? | $\gamma_{\text{Sum(Count)}}(\text{Visits} \bowtie (\sigma_{\text{Name} = \text{'Kuba Kuba'}}(\text{Restaurants}))))$ | 2 |
| What is the highest-rated restaurant with a formal level of "Casual"? | $\text{max(Rating)}(\text{Reviews} \bowtie (\sigma_{\text{Formality Level} = \text{'Casual'}}(\text{Restaurants}))))$ | Picolla Italy Pizza & Subs |
| How many visits were made to Italian restaurants? | $\gamma_{\text{Sum(Count)}}(\text{Visits} \bowtie (\sigma_{\text{Type} = \text{'Italian'}}(\text{Restaurants} \bowtie \text{Location}))))$ | 9 |
| Which restaurants have both sidewalk availability and discounts? | $\pi_{\text{Name}}((\text{Restaurants} \bowtie \text{Accessibility}) \cap (\text{Restaurants} \bowtie \text{Discounts}))$ | Picolla Italy Pizza & Subs, Village Cafe, Crazy Thai Restaurant |
| Which restaurants have the highest average rating? | $\pi_{\text{Name}}(\text{Restaurants} \bowtie (\gamma_{\text{max(Rating)}}(\text{Reviews}) \bowtie \text{Restaurants}))$ | VCU |
| How many reviews have been made for restaurants offering discounts? | $\gamma_{\text{Count(Review ID)}}(\text{Reviews} \bowtie \text{Restaurants} \bowtie \text{Discounts})$ | 4 |
| Which restaurants offer discounts and have a formal level of "Casual"? | $\pi_{\text{Name}}((\text{Restaurants} \bowtie \text{Discounts}) \cap (\sigma_{\text{Formality Level} = \text{'Casual'}}(\text{Restaurants})))$ | Village Cafe, 821 Cafe |
| What is the average rating for restaurants in The Fan neighborhood? | $\gamma_{\text{avg(Rating)}}(\text{Reviews} \bowtie (\text{Restaurants} \bowtie \text{Location}))$ | 3.4 |
| How many restaurants have reviews with ratings above 3.0? | $\gamma_{\text{Count(Restaurant ID)}}(\sigma_{\text{Rating} > 3.0}(\text{Reviews} \bowtie \text{Restaurants}))$ | 5 |
| What is the average total price for restaurants that have nearby bus stops? | $\gamma_{\text{avg(Average Total Price)}}(\text{Restaurants} \bowtie (\sigma_{\text{Nearby Bus Stops} = \text{'Yes'}}(\text{Accessibility} \bowtie \text{Restaurants} \bowtie \text{Location}))))$ | $20.00 |
| What is the total count of visits to "Crazy Thai Restaurant"? | $\gamma_{\text{Sum(Count)}}(\text{Visits} \bowtie (\sigma_{\text{Name} = \text{'Crazy Thai Restaurant'}}(\text{Restaurants}))))$ | 1 |
| What are the restaurants that offer discounts and have a formal level of "Fine Dining"? | $\pi_{\text{Name}}((\text{Restaurants} \bowtie \text{Discounts}) \cap (\sigma_{\text{Formality Level} = \text{'Fine Dining'}}(\text{Restaurants}))))$ | No such restaurants found |
| How many restaurants have reviews with ratings below 4.0? | $\gamma_{\text{Count(Restaurant ID)}}(\sigma_{\text{Rating} < 4.0}(\text{Reviews} \bowtie \text{Restaurants}))$ | 3 |
| Which restaurants have a total count of visits greater than 3? | $\pi_{\text{Name}}(\sigma_{\text{Sum(Count)} > 3}(\text{Visits} \bowtie \text{Restaurants}))$ | No such restaurants found |





## Sample Data Using SQL

This section provides sample data from each table

### Restaurant Table 
The *restaurants* table stores restaurant details, including their unique IDs, names, formality levels, average cost per person, linked location IDs, and cuisine types, providing a comprehensive overview of diverse dining options tied to specific locations.
```{python}
#| echo: false
#| eval: true
#| 
sql = "SELECT * FROM restaurants LIMIT 10;"
try:
    df_people = pd.read_sql(sql, cnx)
    df_people
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df_people = pd.DataFrame()

df_people
```

### Locations Table
The *locations* table records unique locations around the VCU area in Richmond, Virginia, capturing their IDs, addresses, directions from VCU, and neighborhoods, providing a comprehensive catalog of diverse places organized by proximity and neighborhood from the VCU campus.

```{python}
#| echo: false
#| eval: true
#| 
sql = "SELECT * FROM locations LIMIT 10;"
try:
    df_people = pd.read_sql(sql, cnx)
    df_people
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df_people = pd.DataFrame()

df_people
```

### Review Table
The *review* table stores reviews for various restaurants, detailing unique review IDs, associated restaurant IDs, ratings, textual feedback, and the dates the reviews were posted. 

```{python}
#| echo: false
#| eval: true
#| 
sql = "SELECT * FROM review LIMIT 10;"
try:
    df_people = pd.read_sql(sql, cnx)
    df_people
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df_people = pd.DataFrame()

df_people
```

### Accessibility Table
The *accessibility* table catalogues the accessibility features of different restaurants, including their unique IDs, restaurant associations, distances from VCU in miles, details about nearby bus stops, and specific notes. It provides a concise overview of each restaurant's proximity to VCU and nearby transportation options
```{python}
#| echo: false
#| eval: true
#| 
sql = "SELECT * FROM accessibility LIMIT 10;"
try:
    df_people = pd.read_sql(sql, cnx)
    df_people
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df_people = pd.DataFrame()

df_people
```

### Menu Table
The *menu* table typically acts as a linking or organizational structure, connecting specific menus to their respective restaurants. It doesn't directly contain menu items or details; instead, it serves as a reference point, associating menus with their corresponding restaurants through unique identifiers.

```{python}
#| echo: false
#| eval: true
#| 
sql = "SELECT * FROM menu LIMIT 10;"
try:
    df_people = pd.read_sql(sql, cnx)
    df_people
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df_people = pd.DataFrame()

df_people
```

### Item Table 
The *item* table catalogues menu items with unique IDs, encompassing details such as associated dietary preferences, item names, descriptions, and prices, offering a comprehensive inventory of dishes available on a menu. 
```{python}
#| echo: false
#| eval: true
#| 
sql = "SELECT * FROM item LIMIT 10;"
try:
    df_people = pd.read_sql(sql, cnx)
    df_people
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df_people = pd.DataFrame()

df_people
```

### Menu_items
The *menu_items* table establishes relationships between menu IDs, item IDs, and unique menu item IDs. Each row associates specific items with a particular menu by linking the item IDs with menu IDs, allowing for easy identification and retrieval of items that belong to a particular menu within the system.
```{python}
#| echo: false
#| eval: true
#| 
sql = "SELECT * FROM menu_items LIMIT 10;"
try:
    df_people = pd.read_sql(sql, cnx)
    df_people
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df_people = pd.DataFrame()

df_people
```

### Dietary Preference
The *Dietary_Preference* table outlines different dietary preferences, assigning unique IDs to each preference alongside their corresponding names.
```{python}
#| echo: false
#| eval: true
#| 
sql = "SELECT * FROM dietary_preference;"
try:
    df_people = pd.read_sql(sql, cnx)
    df_people
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df_people = pd.DataFrame()

df_people
```

## Sample Test Queries Using SQL
1.Sort the items from Subway that are vegan in ascending order by price.
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT item_name, item_description, item_price
FROM item
JOIN menu_items ON item.item_id = menu_items.item_id
JOIN menu ON menu_items.menu_id = menu.menu_id
JOIN restaurants ON menu.restaurant_id = restaurants.restaurant_id
WHERE restaurants.restaurant_name = 'Subway'
AND item_dietary_preference_id = 20 -- Assuming 'Vegitatrian' has a dietary_preference_id of 20
ORDER BY item_price ASC;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

2.This query retrieves affordable menu items (less than $12) containing "chicken" in their names, displaying their names, descriptions, prices, and the respective restaurant names, sorted by price from least to most expensive.
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT restaurants.restaurant_name, item.item_name, item.item_description, item.item_price
FROM item
JOIN menu_items ON item.item_id = menu_items.item_id
JOIN menu ON menu_items.menu_id = menu.menu_id
JOIN restaurants ON menu.restaurant_id = restaurants.restaurant_id
WHERE item.item_name LIKE '%%chicken%%'
AND item.item_price < 12.00
ORDER BY item.item_price ASC
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

3.This query will retrieve all restaurants that are west of the VCU compass.
```{python}
#| echo: false
#| eval: true
sql = f"""
select restaurant_id, restaurant_name, restaurant_location_id from restaurants
join locations on (restaurant_location_id = location_id) 
where location_direction_from_VCU = 'West'
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

4.This query will retrieve all restaurants that are located on West Grace street.
```{python}
#| echo: false
#| eval: true
sql = f"""
select restaurant_id, restaurant_name, location_address from restaurants
join locations on (restaurant_location_id = location_id) 
where location_address like '%%W Grace%%'
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

5.This query will retrieve a list of the restaurants that are literally on the VCU campus.
```{python}
#| echo: false
#| eval: true
sql = f"""
select * from restaurants
join accessibility on (restaurant_id = accessibility_restaurant_id) 
where accessibility_notes like '%%Literally on campus%%'
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

6.This query will retrieve all the restaurants that offer vegan options , displays the number of vegan dishes per restaurant, finally groups them in descending order.
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT
    restaurants.restaurant_id,
    restaurants.restaurant_name,
    COUNT(menu_items.menu_item_id) AS num_vegan_items
FROM
    restaurants
JOIN
    menu ON restaurants.restaurant_id = menu.restaurant_id
JOIN
    menu_items ON menu.menu_id = menu_items.menu_id
JOIN
    item ON menu_items.item_id = item.item_id
WHERE
    item.item_dietary_preference_id = 20
GROUP BY
    restaurants.restaurant_id, restaurants.restaurant_name
ORDER BY num_vegan_items DESC;

"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

7.This query will retrieve the number of dishes from all the restaurants that are Halal.
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT
    COUNT(item.item_id) AS number_of_halal_dishes
FROM
    item
WHERE
    item.item_dietary_preference_id = 30;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

8.Query to return the Top 10 Rated Restaurants
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT restaurant_name, ROUND(AVG(review_rating), 2) AS average_rating
FROM restaurants
JOIN review ON restaurants.restaurant_id = review.review_restaurant_id
GROUP BY restaurant_name
ORDER BY average_rating DESC
LIMIT 10;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

9.Displaying the count of vegan items each restaurant offers while also displaying their names, addresses, and filtering for locations less than 0.5 miles away:
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT 
    restaurants.restaurant_name,
    locations.location_address,
    COUNT(DISTINCT menu_items.item_id) AS num_vegan_items
FROM restaurants
JOIN menu ON restaurants.restaurant_id = menu.restaurant_id
JOIN menu_items ON menu.menu_id = menu_items.menu_id
JOIN item ON menu_items.item_id = item.item_id
JOIN accessibility ON restaurants.restaurant_id = accessibility.accessibility_restaurant_id
JOIN locations ON restaurants.restaurant_location_id = locations.location_id
WHERE 
    item.item_dietary_preference_id = 20  -- Assuming 'Vegan' has a dietary_preference_id of 20
    AND accessibility.accessibility_miles_to_VCU < 0.5
GROUP BY 
    restaurants.restaurant_name, locations.location_address
ORDER BY 
    num_vegan_items DESC;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

10.This query will retrieve the number of items under 5 dollars each Restauraunt have on thier menu. 
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT 
    restaurants.restaurant_name,
    COUNT(item.item_id) AS num_items_under_5
FROM restaurants
JOIN menu ON restaurants.restaurant_id = menu.restaurant_id
JOIN menu_items ON menu.menu_id = menu_items.menu_id
JOIN item ON menu_items.item_id = item.item_id
WHERE 
    item.item_price < 5.00
GROUP BY 
    restaurants.restaurant_name
ORDER BY 
    num_items_under_5 DESC;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

11.This query returns the total count of menu items available 
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT COUNT(item_id) AS total_menu_items FROM item;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

12.This query retrieves the cheapest item_name and item_cost along with the restaurant it is from.
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT 
    r.restaurant_name,
    i.item_name AS cheapest_item,
    i.item_price AS cheapest_item_price
FROM 
    restaurants r
JOIN 
    menu m ON r.restaurant_id = m.restaurant_id
JOIN 
    menu_items mi ON m.menu_id = mi.menu_id
JOIN 
    item i ON mi.item_id = i.item_id
WHERE 
    i.item_price = (
        SELECT 
            MIN(item_price)
        FROM 
            menu_items mi2
        JOIN 
            item i2 ON mi2.item_id = i2.item_id
        WHERE 
            mi2.menu_id = m.menu_id
    );
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

13.This query retrieves reviews from 2023 for restaurants 
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT r.restaurant_name, re.*
FROM review re
JOIN restaurants r ON re.review_restaurant_id = r.restaurant_id
WHERE SUBSTRING(re.review_date, -4) = '2023';
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

14.This query retrieves number of restaurants by formality number
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT restaurant_formality_level, COUNT(restaurant_id) AS num_restaurants
FROM restaurants
GROUP BY restaurant_formality_level
ORDER BY num_restaurants DESC;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

15.This query retrieves the number of restaurants per neighborhood
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT location_neighborhood, COUNT(restaurant_id) AS num_restaurants
FROM locations
JOIN restaurants ON locations.location_id = restaurants.restaurant_location_id
GROUP BY location_neighborhood
ORDER BY num_restaurants DESC;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

16.This query retrieves a table showing the count of dietary preferences for Mamusa's African Restaurant
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT dp.dietary_preference_name, COUNT(item.item_id) AS preference_count
FROM restaurants r
JOIN menu ON r.restaurant_id = menu.restaurant_id
JOIN menu_items ON menu.menu_id = menu_items.menu_id
JOIN item ON menu_items.item_id = item.item_id
JOIN dietary_preference dp ON item.item_dietary_preference_id = dp.dietary_preference_id
WHERE r.restaurant_name = 'Mamusa''s African Restaurant'
GROUP BY dp.dietary_preference_name
ORDER BY preference_count DESC;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

17.This query groups the restaurants by their types (restaurant_type) and counts the number of restaurants within each type using COUNT
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT restaurant_type, COUNT(restaurant_id) AS type_count
FROM restaurants
GROUP BY restaurant_type
ORDER BY type_count DESC ;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

18.This retrieve restaurants that are Mediterranean and offer vegetarian options.
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT *
FROM restaurants r
WHERE r.restaurant_type = 'Mediterranean'
AND EXISTS (
    SELECT 1
    FROM menu m
    JOIN menu_items mi ON m.menu_id = mi.menu_id
    JOIN item i ON mi.item_id = i.item_id
    WHERE m.restaurant_id = r.restaurant_id
    AND i.item_dietary_preference_id = (
        SELECT dietary_preference_id
        FROM dietary_preference
        WHERE dietary_preference_name = 'Vegetarian'
    )
);
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

19.This query retrieves restaurants that offer Italian cuisine.
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT *
FROM restaurants
WHERE restaurant_type = 'Italian';
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```

20.This query that lists restaurants offering vegetarian options and their respective counts of vegetarian menu items
```{python}
#| echo: false
#| eval: true
sql = f"""
SELECT r.restaurant_name, COUNT(i.item_id) AS num_vegetarian_items
FROM restaurants r
JOIN menu m ON r.restaurant_id = m.restaurant_id
JOIN menu_items mi ON m.menu_id = mi.menu_id
JOIN item i ON mi.item_id = i.item_id
JOIN dietary_preference dp ON i.item_dietary_preference_id = dp.dietary_preference_id
WHERE dp.dietary_preference_name = 'Vegetarian'
GROUP BY r.restaurant_name
ORDER BY num_vegetarian_items DESC;
"""
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```


# Project Management

## Project Schedule

Create a Gantt chart with Deliverables and milestones to ensure that the project is completed on time, considering the submission deadline.


```{mermaid}
gantt
title CMSC 508 Fall Semester Project
dateFormat YYYY-MM-DD
axisFormat %m-%d

section Tasks
Find a Prompt : done, des1, 2023-08-27, 2023-08-29
Find a Partner : done, des2, 2023-09-18, 2023-09-20
Video Proposal : done, des3, 2023-10-01, 2023-10-04
Project Design : active, des4, 2023-10-04, 2023-10-15
Work on Database Pt1 : des5, 2023-10-15, 2023-11-01
Work on Database Pt2 : des6, 2023-11-01, 2023-11-20
Final Submission : des7, 2023-12-01, 2023-12-12

section Edwin Constancia
Discuss Idea for Database : done,des8, 2023-09-18, 2023-09-20
Define Database Scheme/Queries/Design : done,des9, 2023-10-01, 2023-10-14
Build Database Tables based on Design : des10, 2023-10-15, 2023-10-25
Populate Database with Sample Data : des11, 2023-10-26, 2023-11-15
Test Database operations : des12, 2023-11-16, 2023-12-09

section Alex Welk
Discuss Idea for Database : done,des13, 2023-09-18, 2023-09-20
Define Create ER Diagram/Project Overview/Design : done,des14, 2023-10-01, 2023-10-14
Define the Data relationships in Database : des15, 2023-10-15, 2023-10-25
Define Data Constraints : des14, 2023-10-26, 2023-11-15
Implement Security measures user access contol : des15, 2023-11-15, 2023-12-09

section Milestones
Milestone 1 Find Prompt: crit, 2023-08-29, Milestone 1: Find a Prompt Complete
Milestone 2 Find Partner: crit, 2023-09-20, Milestone 2: Find a Partner Complete
Milestone 3 Purpose Idea: crit, 2023-10-04, Milestone 3: Video Proposal Complete
Milestone 4 Project Design: crit, 2023-10-15, Milestone 4: Project Design Complete
Milestone 5 Database pt 1 : crit, 2023-11-01, Milestone 5: Work on Database 1 Complete
Milestone 6 Database pt 2: crit, 2023-11-20, Milestone 6: Work on Database 2 Complete
Milestone 7 Final : crit, 2023-12-12, Milestone 7: Final Submission    
```

## API Definition

### Accessing the Database

Your database is accessible through a RESTful API. The following endpoints allow access to the database:


### API Demonstration

A demonstration of the API's functionality can be showcased using tools like cURL or Postman. Here's an example:
- Using cURL: `curl -X GET http://your-api-endpoint/restaurants`
- Using Postman: Create a GET request to `http://your-api-endpoint/restaurants`

## Source Code Links

- [DDL SQL Code](https://github.com/cmsc-vcu/cmsc508-fa2023-prj-restaurantdirectory-group21/blob/main/src/restaurantdirectory-ddl.sql)
- [DML SQL Code](https://github.com/cmsc-vcu/cmsc508-fa2023-prj-restaurantdirectory-group21/blob/main/src/restaurantdirectory-dml.sql)

## Future Considerations

- Implementing user authentication and authorization for API access.
- Optimizing endpoint responses by implementing pagination and filtering.

## Reflections on the Project

The project went well overall. The initial goals were mostly achieved, alt
